<!-- 地址: http://gmall-h5-api.atguigu.cn -->
<!-- 接口: /api/product/getBaseCategoryList -->

1. 基础配置：
1.1 浏览器自动打开 --- package.json script 加上后缀 --open ("serve": "vue-cli-service serve --open")
1.2 关闭eslint --- vue.config.js 加上 (lintOnSave : false)

2. 基本组件
2.1 Home首页路由组件、Search路由组件、Login路由组件、Refister路由组件
2.2 非路由组件 ： Header【首页|搜索框】、Footer【首页|搜索框】(登录页面没有)

3. 环境配置 : less-loader---@5 版本

4. 文件夹配置：
public : 放置静态资源(图片)，webpack打包时原封不动打包到dist
assets : 也是放置静态资源，但是打包时会被当成模块打包到js文件内
pages : 用来放路由组件
router : 用来放路由规则文件 router.js
store : vuex仓库
api : api接口文件
utils : 放置自定义文件包

=============================================
5.1. home组件开发步骤：
a. 模块化配置home组件
b. 重写搜索框的编程式导航的push未指定回调多次点击报错的问题
c. 配置axios请求，不设置地址，只有url，用代理来进行模拟练习

d. nprogress包配合进度条使用,在拦截器设置开启关闭，使用axios实例对象发请求时，拦截器要配置在实例对象上

e. TypeNav组件发布store管理请求，使用vuex管理请求回来的数据，渲染的到导航栏的三级分类区域，
vuex请求数据可以在app根组件进行数据初始化，后续不会再次请求影响性能

f. 用js完成鼠标选中变色事件，不要用hover,锻炼一下 ；同理用js完成二三级栏显示隐藏，都是三元表达式配合v-for完成

 g. 给一级导航设置节流，防止鼠标移动过快

 h. 对三级导航设置路由跳转，由于rouer-link数量较多时影响性能，因此采用编程式导航，并且将触发事件委派给父元素进行代理，减少内存消耗 ; 采用添加自定义属性的方法来筛选是否为所需元素

 i. 三级联动导航只在home页面默认展示，所以设置v-show或if控制显示隐藏，且在声明周期函数的渲染阶段进行判断，路径没有'/home'就隐藏 ; 
 移入移出的展示也要先判断路径 
 对一级分类栏添加过渡动画;

 j. 合并参数 ：通过侧边栏跳转的search路径携带了query,搜索框跳转的路径会携带params参数,因此要进行合并

 k. mockjs模拟数据---步骤:
 1. src创建mock文件夹
 2. mock下创建需要的数据的json文件
 3. 创建mockServe.js入口文件
 4. main.js直接引入

 l. 添加新的ajax请求，通过banner图的组件发起vuex事件，再请求模拟的mock数据

 m. 使用swiper包，配合js实现轮播图 : 
 1. 问题1:使用watch深度监听数据是否响应完毕
 2. 问题2:还需要解决判断v-for遍历渲染完毕---配合nextTick使用，等待渲染完毕再执行swiper实例化

 n. 在home组件请求floor的数据，遍历循环创建子组件floor,并把请求到的数据在floor标签遍历，并把遍历值传递给对应floor组件，从而提高复用性

 o. 将轮播图封装成一个组件，直接插入组件传递数据就行

============================================

 5.2 开发search组件
 a. 完善search仓库管理vuex，发起search请求,组件暂存数据;注意发起请求时数据要默认传个{},否则会响应失败

 b. 利用getters简化返回的数据，但是要注意state返回失败时空对象的情况，因此要getters简化数据还要加一种或情况 || [] ，万一state是{}也不会出现undefined的情况

 c. 利用Object.assign将数据和路径进行对象拼接进行拼接并将数据发送给接口,以此获得对应的数据 

 d. 完成search子组件的动态渲染

 e. 完成搜索框和分级导航的联动刷新，监听路径变化，将对象合并更新后重新发送数据渲染；注意提交后要清空分级id，因为不重复的id会叠加而不是覆盖

 f. 面包屑完善，
 1. 根据选择的分类的关键字进行动态展示，即searchParams的名字参数 ; 点击删除关键字发送请求后path地址没进行刷新，因此要手动跳转 ; 
 2. 添加关键字面包屑，删除时手动跳转，同时传递事件给header组件清空输入框 ; 手动跳转要注意是否携带路径参数
 3. 根据点击的品牌添加面包屑,需要search组件和其子组件进行配合

 g. attr属性值点击触发事件和面包屑完善:数组过滤和数组去重

 h. 使用order指令向服务器发起排序指令 ; 
 1. 利用iconfont在线链接渲染箭头并控制是否展示，三元表达式进行判断
 2. 利用点击事件进行切换，注意判断点击的是哪一个，执行什么操作，默认是升序还是降序

 i. 分页器 : 常见显示数字的页数(5||7)页，好看且对称，其它...代替
 1. pageNo---代表当前页数 pageSize---每一页展现的数据数量 total---数据总量 continues---分页连续页码的数量(5||7)页  
 2. 测试分页器: 数据通过search组件进行模拟传递,
 2.1 求出总页数 ：向上取整( 数据总量 / 每一页数据量 )进行动态展示
 2.2 连续页码为当前页面和前后个各两页组成 ；但是前后两端会出现负数或者大于页面总数的情况, 因此出现负数时，从第一页开始，往后展示连续页数的要求页数就行例如当前为第2页，直接展示练习1~5就行，从第三页开始才计算前后页数 ；同理后面往前延续5页就行
 2.3 动态渲染连续的页数 ； 根据头尾数调整是否需要渲染 ... 注意调整首尾页和和省略号要用首尾页和总页数进行判断，用当前页面会造成修改容量出bug
 3. 动态渲染完成分页器 :
 3.1 子组件传递页面点击事件和当前页数
 3.2 父组件接收数据并修改searchParams数据重新发送请求
 3.3 禁用页面组件的上下页按钮
 3.4 添加当前选中页面的class样式
 3.5 暂时修改小bug，如果当前页数>响应回来的页数(其他事件会发请求)，则重新发送事件和当前响应页数进行请求

 ================================

 5.3 详情页面开发
 a. 点击商品图片跳转详情页页面，要传递商品id数据 ；跳转路由后要重置滚动条，利用vue-router官方提供的滚动事件进行处理

 b. 跳转页面够挂在前进行数据请求 ; 建立datail模块的store仓库 ; 将返回的数据进行动态渲染 ; 子组件放大框图片，下方轮播图渲染 ; 右侧注意根据返回的数据进行当前选中进行渲染

 c.排他思想处理商品属性 ； 处理左端页面小轮播图 ； 处理放大框
 
 d. 处理购物车数量，通过文本框聚焦和失去焦点获得事件，修改输入的合法数值

 e. 点击购物车判断是否成功 --- 根据提交事件dispatch后store返回的Promise状态进行判断,所以响应失败就返回new Error的Promise值

 f. 简单数据通过query进行传递 ； 复杂数据用session(单页面可以用)或local（跨页面）进行传递

======================================
5.4 购物车页面开发
 a. 添加购物车页，查看详情按钮设置跳转回详情页，携带id参数 ; 点击查看购物车按钮，跳转购物车路由组件

 b. 调整购物车组件界面，新建购物车仓库存储购物车信息，发送请求购物车 : 
 1. 发送请求不能携带参数，通过请求头添加userTempId用户数据发送请求获取指定响应
 2. 用户数据用uuid进行模拟，生成一次就可以保存到token,生成的数据保存到store的detail仓库
 3. 拦截器对request请求携带请求头添加userTempId用户数据

 c. 在页面渲染完毕后mounted进行数据请求，获取数据初始化仓库，利用数据动态渲染购物车页面

 d. 对购物车数量进行调节，通过再次发布事件，发送添加购物车请求修改数量，+ - 文本框 都会触发同一事件，要进行区分，通过传参进行区分
 ps：接口接收到的数量是要添加的数量，不是修改后的数量

 e. 删除商品，发送带id的接口请求 ；
 f. 修改商品选中状态，根据商品选中接口 ,配合手写节流，直到返回成功才允许点击按钮

 g. 批量删除选中的产品按钮，发布删除全部事件的dispatch，在store的action下重复调用枚举删除 ； 返回多个Promise可以转化成数组进行promise.all判断
 ps : 返回的数组放的是promise形态的值，不需要进行await解析

 h. 全选按钮发送请求，将未选中的框进行发送请求更新

 ========================================
 5.5 登录注册功能页面开发
 a. 获取页面组件，修改页面

 b. 完善注册页面
 1. 正则判断文本框格式 ； 点击获取验证码则发送请求，用user的store仓库进行保存响应数据，会返回验证码 ；vuex模拟接收到的验证信息,进行保存输入，为了省时间进行这里直接从仓库获取并且自动填充文本框
 2. 完成注册按钮发布事件，在user的store仓库发送请求进行注册，
 3. 点击注册按钮成功后跳转登录界面 ; 先检测是否勾选协议文本框

 c. 完善登录页面
 1. 点击登录发送username和password请求，在仓库进行发送 ； 返回带token的数据，将其保存在localStorage
 ps : 保存token的功能函数可以封装成单独的模块放在utils
 2. 发送token进行用户验证，返回带用户信息的data ；根据返回的data进行头组件Header的渲染修改 ; ps : 要携带token的请求头信息才会验证成功
 3. 退出功能的完善 , 发送退出请求，服务器响应清空请求头发送的token ; 清空本地token后返回首页

 ======================
 5.6 登录问题完善
 a. user仓库的state的token会自动获取本地的token ；

 b. 进入home页面自动发送一次请求，利用仓库的token发送请求进行用户数据验证，成功则修改header部分的文本
 ps:不经过home页面是不能获取用户名渲染页面, 配合导航守卫，判断仓库是否有用户名，没有就给他拉回home页面

 c. 配置导航守卫 : 
 1. 根据store仓库的user模块是否有token判断是否放行 ：没有返回首页
 2. 有token跳转login页面或注册register页面将其导向home页面 ; 
 3. 跳转其他页面则判断仓库除了token是否有userInfo, 有就放行，没有则获取用户信息，发布事件更新user仓库再放行 ; 获取失败则先发布logout事件清空服务器token,再返回登录界面
 ps : 直接导入store的总仓库，可以使用dispatch
 小bug : 已修复 ，由于一直返回身份信息失败，但是store的token一直存在会死循环，要清空

 ============================================
 5.7 订单页面开发（携带的token只能是1370000000 111111 ；其他账号没有订单信息）
 a. 整理trade静态页面组件
 b. 发起获取地址信息请求 ；获取货物信息请求 ; 创建trade仓库模块进行存储

 bug : 选中地址的异步请求未返回时执行computed会报错(已修复) ; 根据返回的默认地址进行填充处理

--------------接下来不进行vuex处理请求，直接和data对接
 c. 提交订单获取交易码，将填写的信息收集好进行请求后，返回成功才能跳转

 d. 跳转的提交订单成功页面path要携带query参数进行跳转，请求支付后会返回支付二维码

 e. 点击支付页面显示element弹窗，将返回的二维码字符串通过qrcode包解析后放在上面 ；用定时器控制一定时间自动发送支付请求，成功就关闭定时器并清空

 f. 跳转支付成功的页面,页面路径变了就停止计时

 ===========================
 5.8 center组件开发
 a. 拆分侧边栏二级路由

 b. 进入页面请求i订单进行渲染, 初始化页数和每页数量在进行请求提交 ; rowspen要进行动态设置合成的行数，否则页面会出问题 ; 多行合成动态创建时也会创建，因此只显示index==0的多行合成